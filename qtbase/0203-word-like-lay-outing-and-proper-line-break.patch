From f116f0ad6095a1e2c90766a8248603e5bd6eb49d Mon Sep 17 00:00:00 2001
From: Michal Lazo <michal.lazo@memsource.com>
Date: Fri, 10 Jun 2022 09:53:28 +0200
Subject: [PATCH] word like lay-outing and proper line-break

---
 src/gui/text/qtextengine.cpp | 12 +++---
 src/gui/text/qtextlayout.cpp | 80 +++++++++++++++++++++++++++++++-----
 src/gui/text/qtextoption.h   |  1 +
 3 files changed, 76 insertions(+), 17 deletions(-)

diff --git a/src/gui/text/qtextengine.cpp b/src/gui/text/qtextengine.cpp
index ac50d5b24e..9e674f762a 100644
--- a/src/gui/text/qtextengine.cpp
+++ b/src/gui/text/qtextengine.cpp
@@ -1965,7 +1965,7 @@ void QTextEngine::itemize() const
                 string = reinterpret_cast<const ushort *>(layoutData->string.unicode());
                 uc = string + offset;
                 e = string + length;
-                *const_cast<ushort*>(uc) = 0x21B5; // visual line separator
+                *const_cast<ushort*>(uc) = 0x21a9;
             }
             break;
         case QChar::Tabulation:
@@ -1973,12 +1973,12 @@ void QTextEngine::itemize() const
             analysis->bidiLevel = bidi.baseLevel;
             break;
         case QChar::Space:
+        case 0x3000: // IdeologicalSpace
+            analysis->flags = QScriptAnalysis::Space;
+            break;
         case QChar::Nbsp:
-            if (option.flags() & QTextOption::ShowTabsAndSpaces) {
-                analysis->flags = (*uc == QChar::Space) ? QScriptAnalysis::Space : QScriptAnalysis::Nbsp;
-                break;
-            }
-            Q_FALLTHROUGH();
+            analysis->flags = QScriptAnalysis::Nbsp;
+            break;
         default:
             analysis->flags = QScriptAnalysis::None;
             break;
diff --git a/src/gui/text/qtextlayout.cpp b/src/gui/text/qtextlayout.cpp
index dfcbf6a786..ece07a7576 100644
--- a/src/gui/text/qtextlayout.cpp
+++ b/src/gui/text/qtextlayout.cpp
@@ -1706,7 +1706,7 @@ namespace {
 
         inline void calculateRightBearing()
         {
-            if (currentPosition <= 0)
+            if (currentPosition <= 0 || glyphs.numGlyphs == 0 || logClusters[currentPosition-1] >= glyphs.numGlyphs)
                 return;
             calculateRightBearing(fontEngine, currentGlyph());
         }
@@ -1834,6 +1834,9 @@ void QTextLine::layout_helper(int maxGlyphs)
     bool hasInlineObject = false;
     QFixed maxInlineObjectHeight = 0;
 
+    bool useWordLikeLayout = eng->option.flags() & QTextOption::WordLikeLayout;
+    bool previousSpace = false;
+
     while (newItem < eng->layoutData->items.size()) {
         lbh.resetRightBearing();
         if (newItem != item) {
@@ -1905,10 +1908,19 @@ void QTextLine::layout_helper(int maxGlyphs)
                 lbh.tmpData.length++;
                 lbh.calculateRightBearingForPreviousGlyph();
             }
-            line += lbh.tmpData;
+            if (useWordLikeLayout) {
+                lbh.checkFullOtherwiseExtend(line);
+            } else {
+                line += lbh.tmpData;
+            }
             manuallyWrapped = true;
             goto found;
         } else if (current.analysis.flags == QScriptAnalysis::Object) {
+            if (useWordLikeLayout &&
+                ((breakany && lbh.checkFullOtherwiseExtend(line)) ||
+                (previousSpace == true && lbh.checkFullOtherwiseExtend(line)))) {
+                goto found;
+            }
             lbh.whiteSpaceOrObject = true;
             lbh.tmpData.length++;
 
@@ -1929,11 +1941,13 @@ void QTextLine::layout_helper(int maxGlyphs)
 
             newItem = item + 1;
             ++lbh.glyphCount;
-            if (lbh.checkFullOtherwiseExtend(line))
+            if (!useWordLikeLayout && lbh.checkFullOtherwiseExtend(line))
                 goto found;
-        } else if (attributes[lbh.currentPosition].whiteSpace
+        } else if (!useWordLikeLayout &&
+                   attributes[lbh.currentPosition].whiteSpace
                    && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak) {
             lbh.whiteSpaceOrObject = true;
+            lbh.saveCurrentGlyph();
             while (lbh.currentPosition < end
                    && attributes[lbh.currentPosition].whiteSpace
                    && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak) {
@@ -1941,14 +1955,31 @@ void QTextLine::layout_helper(int maxGlyphs)
                                current, lbh.logClusters, lbh.glyphs);
             }
+
+            lbh.saveCurrentGlyph();
         } else {
-            if (!lbh.manualWrap && lbh.spaceData.textWidth > line.width)
+            if (!lbh.manualWrap && lbh.checkFullOtherwiseExtend(line)) {
+                lbh.spaceData.textWidth = 0;
+                lbh.spaceData.length = 0;
                 goto found;
+            }

             lbh.whiteSpaceOrObject = false;
             bool sb_or_ws = false;
+            bool canBreak = false;
             lbh.saveCurrentGlyph();
             QFixed accumulatedTextWidth;
             do {
+                if (useWordLikeLayout) {
+                    const bool noBreak = eng->layoutData->string.at(lbh.currentPosition).decompositionTag() == QChar::NoBreak;
+
+                    if (!noBreak && attributes[lbh.currentPosition].whiteSpace) {
+                        previousSpace = true;
+                    } else if (previousSpace) {
+                        canBreak = true;
+                        break;
+                    }
+                }
+                
                 addNextCluster(lbh.currentPosition, end, lbh.tmpData, lbh.glyphCount,
                                current, lbh.logClusters, lbh.glyphs, &accumulatedTextWidth);
 
@@ -1963,12 +1991,19 @@ void QTextLine::layout_helper(int maxGlyphs)
                                         && attributes[lbh.currentPosition].whiteSpace
                                         && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak;
 
-                if (lbh.currentPosition >= eng->layoutData->string.size()
+                if (!useWordLikeLayout 
+                    && (lbh.currentPosition >= eng->layoutData->string.size()
                     || isBreakableSpace
                     || attributes[lbh.currentPosition].lineBreak
-                    || lbh.tmpData.textWidth >= QFIXED_MAX) {
+                    || lbh.tmpData.textWidth >= QFIXED_MAX)) {
                     sb_or_ws = true;
                     break;
+                } else if (useWordLikeLayout 
+                    && (lbh.currentPosition >= eng->layoutData->string.size()
+                    || (isBreakableSpace && attributes[lbh.currentPosition].lineBreak)
+                    || lbh.tmpData.textWidth >= QFIXED_MAX)) {
+                    canBreak = true;
+                    break;
                 } else if (attributes[lbh.currentPosition].graphemeBoundary) {
                     if (breakWordOrAny) {
                         lbh.minw = qMax(accumulatedTextWidth, lbh.minw);
@@ -2002,7 +2037,8 @@ void QTextLine::layout_helper(int maxGlyphs)
                 lbh.currentSoftHyphenWidth = lbh.glyphs.advances[lbh.logClusters[lbh.currentPosition - 1]];
             }
 
-            if (sb_or_ws|breakany) {
+            if (canBreak|sb_or_ws|breakany) {
+                previousSpace = false;
                 // To compute the final width of the text we need to take negative right bearing
                 // into account (negative right bearing means the glyph has pixel data past the
                 // advance length). Note that the negative right bearing is an absolute number,
@@ -2515,8 +2551,9 @@ void QTextLine::draw_internal(QPainter *p, const QPointF &pos,
     QPen pen = p->pen();
 
     bool noText = (selection && selection->format.property(SuppressText).toBool());
+    bool rtl = (eng->block.document() && eng->block.document()->defaultTextOption().textDirection() == Qt::RightToLeft);
 
-    if (!line.length) {
+    if (!line.length && !(eng->option.flags() & QTextOption::ShowLineAndParagraphSeparators)) {
         if (selection
             && selection->start <= line.from
             && selection->start + selection->length > line.from) {
@@ -2706,7 +2743,28 @@ void QTextLine::draw_internal(QPainter *p, const QPointF &pos,
         } else {
             if (noText)
                 gf.glyphs.numGlyphs = 0; // slightly less elegant than it should be
-            QPainterPrivate::get(p)->drawTextItem(pos, gf, eng);
+            if ((eng->option.flags() & QTextOption::ShowLineAndParagraphSeparators) &&
+                si.analysis.flags == QScriptAnalysis::LineOrParagraphSeparator) {
+                QChar visualLine;
+                if ((index == eng->lines.size() - 1) && (eng->block.next().isValid() != false)) { // newline
+                    visualLine = (ushort)0xb6;
+                    if (rtl)
+                        pos = QPointF((line.width - line.textWidth).toReal(), y.toReal());
+                } else if (iterator.itemStart < (eng->layoutData->string.length() - 1)) { // lineseparator
+                    if (rtl)
+                        pos = QPointF((line.width - line.textWidth).toReal(), y.toReal());
+                    visualLine = ((ushort)0x21a9);
+                }
+                if (visualLine.unicode()) {
+                    QBrush c = format.foreground();
+                    if(c.style() != Qt::NoBrush)
+                        p->setPen(c.color());
+                    p->drawText(pos, visualLine);
+                    p->setPen(pen);
+                }
+            } else {
+                QPainterPrivate::get(p)->drawTextItem(pos, gf, eng);
+            }
         }
 
         if ((si.analysis.flags == QScriptAnalysis::Space
diff --git a/src/gui/text/qtextoption.h b/src/gui/text/qtextoption.h
index 2955fe8dcc..25a9352308 100644
--- a/src/gui/text/qtextoption.h
+++ b/src/gui/text/qtextoption.h
@@ -109,6 +109,7 @@ public:
         AddSpaceForLineAndParagraphSeparators = 0x4,
         SuppressColors = 0x8,
         ShowDocumentTerminator = 0x10,
+        WordLikeLayout = 0x20,
         IncludeTrailingSpaces = 0x80000000
     };
     Q_DECLARE_FLAGS(Flags, Flag)
-- 
2.26.1.windows.1

